{"title":"Metal.js","githubRepo":"metal/metaljs.com","googleAnalytics":"UA-37033501-7","index":{"title":"Metal.js","description":"Build UI components in a solid, flexible way.","content":" Brought to you by Liferay, Inc. © 2017. Powered by WeDeploy™ ","srcFilePath":"src/pages/index.soy","id":"pages","url":"/./","children":{"docs":{"title":"Documentation","description":"Everything you need to know to get started.","content":" Docs Start learning how to leverage the power of . Get started right away with Quick Start Tutorals, or dig into the details with Guides. Each guide provides step by step coverage for that core feature. ","srcFilePath":"src/pages/docs/index.soy","id":"docs","url":"/docs/","children":{"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how to leverage the power of . ","srcFilePath":"src/pages/docs/search.soy","id":"search","url":"/docs/search.html"},"getting-started":{"title":"Quick Start","description":"","layout":"guide","icon":"flash","weight":1,"content":" Getting Started There are many different ways to build components using Metal.js. You can use the built-in integrations with {sp}Soy or {sp}JSX templates, or even build your own template abstraction on top of Metal.js and use it instead. You can build the ES6 code using Babel, Traceur or any other transpiler. You can test using Karma, Jasmine or any other test framework, and can use any directory structure for your project. To sum it up, you can customize everything to your own needs. The world is your oyster. This guide will focus on a quick and easy way to get started with Metal.js. But if you are excited to try it out as soon as possible you can just play around with this JSFiddle. Boilerplate You can organize your Metal.js project in any way you want, but to start out we recommend using the Yeoman Generator{sp} we've created, which prepares both the project structure as well as a basic development workflow for you. You can use it if you wish, but to makes things even simpler we're providing a zip with the boilerplate that the generator would create for this tutorial, so you can just download it here: Download Metal.js Boilerplate (with Soy) Download Metal.js Boilerplate (with JSX) Note that this zip you've downloaded contains not only the starting boilerplate, but also a folder for each step of this tutorial guide, so that you can either code along with us or just check out the final code for each step. Now that you have the boilerplate, you just need to: Install npm v3.0.0 or newer (if you don't have it yet). For Soy users only: Install {sp}Java{sp} version 8 or newer (if you don't have it yet). Enter the 1. Hello World/ folder in your terminal and install its npm dependencies, by typing: [sudo] npm install Once the dependency installation ends, you'll get a directory tree similar to this: ├── demos │ └── index.html ├── node_modules ├── package.json ├── src │ ├── Modal.js │ ├── Modal.soy // Only if Soy was chosen │ └── modal.scss └── test └── Modal.js Build If you open the generated src/Modal.js file you may notice that it's using {sp} ES6 syntax: class Modal extends ... That means that it'll need to go through a build process, since browsers haven't fully implemented all ES6 features yet. generator-metal already prepares some useful scripts that you can use, including a build script. By default, this script will build everything into global variables. To use it, simply type: npm run build Demo Page Now that the code was built, just open the generated demos/index.html file on your browser. It should display a nice Hello World message, like this: If you look at the contents of demos/index.html, you'll see how the component is being rendered. In this example, it's simply being instantiated directly by calling new metal.Modal();. By default this will append the component to the document's body. If you want though, you can specify where it should be rendered. Check the guide about {sp}rendering components to find out how. Hello World As you've noticed, the generated project automatically renders {sp}Hello World for you. Curious to see how that's done? It's simple, just take a look at the generated template: // src/Modal.soy &123;namespace Modal&#125; /** This renders the component's whole content. Note: has to be called \".render\". */ &#123;template .render&#125; Hello World &#123;/template&#125; // src/Modal.js import JSXComponent from 'metal-jsx'; class Modal extends JSXComponent { render() { return Hello World; } } export default Modal; You can replace the default content with any other to change what your component renders. Just make sure to build the code again after making your changes. Next Steps Now that you have gone through running a simple Hello World component, let's actually turn it into a Modal. ↪ Tutorial: Modal ","srcFilePath":"src/pages/docs/getting-started/index.md","id":"getting-started","url":"/docs/getting-started/","children":{"modal":{"title":"Tutorial: Modal","description":"","layout":"guide","weight":100,"content":" In the previous section you learned how to build a simple project using Metal.js that just renders Hello World on the screen. Let's enhance what we already have to render a modal dialog instead. Rendering Our generated project already includes {sp}Bootstrap's CSS, so let's use its markup for our modal. Let's update the component's template to do that then: // src/Modal.soy &123;namespace Modal&#125; /** This renders the component's whole content. Note: has to be called \".render\". */ &#123;template .render&#125; {@param body: string} {@param header: string} × {$header} {$body} OK &#123;/template&#125; // src/Modal.js import JSXComponent from 'metal-jsx'; class Modal extends JSXComponent { /** Renders the component's content. Note that data can be accessed via the props property. */ render() { return × {this.props.header} {this.props.body} OK ; } } export default Modal; Passing Data Note that the template is accessing data to determine the content of the modal's header and body. How can the component receive this data though? One way is through the component's constructor. When creating component instances directly, you can pass them a data object as its first param. So let's update our demo to pass it some data: new metal.Modal({ header: 'My Modal', body: 'Built using Metal.js' }); Run the Demo Now compile your code with npm run build and open the demo on a browser, and you should be seeing this: Next Steps We've taken care of the rendering, but you'll notice that clicking the *x*{sp} button doesn't do anything yet though. Let's make that work. ↪ Tutorial: Modal - Events ","srcFilePath":"src/pages/docs/getting-started/modal.md","id":"modal","url":"/docs/getting-started/modal.html"},"modal_events":{"title":"Tutorial: Modal - Events","description":"","layout":"guide","weight":200,"content":" In the previous section we've created a component that renders a Modal. Its close button doesn't do anything yet though. This section will teach you how to handle DOM events on your components. Inline Listeners - via Function Name You can add DOM event listeners easily through your templates, like this: The above code declares that whenever the *x* button is clicked, the {sp}close function from the component should be called. Inline Listeners - via Function Reference If you prefer though, you can also pass the actual function reference (instead of just its name) as an inline listener. // src/Modal.soy /** In the \"render\" template, Soy params that match a component's function name will be that function (automatically bound to the component instance). */ &#123;template .render&#125; {@param close: any} // ... // ... &#123;/template&#125; // src/Modal.js That will work exactly the same way as the previous example. Listener Implementation All you need to do now is to implement the close function in your {sp}src/Modal.js file: close() { this.dispose(); } All components have this dispose function, which basically destroys it and removes its content from the DOM. Check the guide about {sp}Lifecycle functions for more details. Run the Demo Now compile your code with npm run build and open the demo on a browser. Clicking the *x* button will close the modal as expected. For more details on inline listeners check {sp}this guide. Next Steps Our modal now properly closes itself when the *x* button is clicked. To do this we're disposing of it completely though, so we'll need to create a new Modal instance whenever we need to show it again. Ideally, instead of disposing it, we should just hide it instead, while also having a way to show it back. The next section will explain how to do this by having data changes update the modal accordingly. ↪ Tutorial: Modal - Updates ","srcFilePath":"src/pages/docs/getting-started/modal_events.md","id":"modal_events","url":"/docs/getting-started/modal_events.html"},"modal_nested":{"title":"Tutorial: Modal - Nested Components","description":"","layout":"guide","weight":400,"content":" In the previous section we finished working on our component's behavior. But what if our Modal header's markup was very similar to one that is used in other places though? Ideally we'd move it into a separate component that can be reused. That's what we'll be doing in this section. Creating CloseHeader First let's create the new component. Add a src/CloseHeader.js file to your project: // src/CloseHeader.js import templates from './CloseHeader.soy'; import Component from 'metal-component'; import Soy from 'metal-soy'; class CloseHeader extends Component { } Soy.register(CloseHeader, templates); export default CloseHeader; // src/CloseHeader.js import JSXComponent from 'metal-jsx'; class CloseHeader extends JSXComponent { render() { } } export default CloseHeader; Now let's prepare the template to be similar to the one used by Modal: // src/CloseHeader.soy &123;namespace CloseHeader&#125; &#123;template .render&#125; {@param cssClass: string} {@param onClick: any} {@param title: string} × {$title} &#123;/template&#125; // src/CloseHeader.js render() { return × {this.props.title} ; } Done! Our new component is ready to be used by Modal. Using CloseHeader All we have to do is to replace the header markup from Modal's template with a call to CloseHeader: // src/Modal.soy &123;template .render&#125; {@param body: string} {@param close: string} {@param header: string} {@param shown: bool} {call CloseHeader.render} {param cssClass: 'modal-header' /} {param onClick: $close /} {param title: $header /} {/call} {$body} OK &#123;/template&#125; // src/Modal.js render() { var cssClass = 'modal'; if (this.props.shown) { cssClass += 'show'; } return {this.props.body} OK ; } This will not only render CloseHeader at the right position, but also instantiate it for you. For more details on nested components, check out the {sp}guide about it. Next Steps Now that we have learned how to properly create a new component, it'd good to also know how to test it. The next section will focus on that. ↪ Tutorial: Modal - Testing ","srcFilePath":"src/pages/docs/getting-started/modal_nested.md","id":"modal_nested","url":"/docs/getting-started/modal_nested.html"},"modal_testing":{"title":"Tutorial: Modal - Testing","description":"","layout":"guide","weight":500,"content":" In the previous section we've completed our Modal component. The last thing we'd like to show is how to use the tools that Metal.js offers to help you test your code. Test Script If you look at your package.json file you'll notice that it already contains a test script that you can use: { \"scripts\": { \"test\": \"gulp test\" } } If you're building a project without the generator, you can still get {sp}Metal.js's test tools by using gulp-metal. Adding a Test Also note that your generated project directory also has a file called {sp}test/Modal.js, with a failing assertion. As you can imagine, all you need to do is add your tests to this file. To illustrate this let's start by replacing the existing test with one that checks that the given body data is being rendered correctly: import Modal from '../src/Modal'; describe('Modal', function() { it('should render the body', function() { var component = new Modal({ body: 'Test Body' }); var bodyElement = component.element.querySelector('.modal-body'); assert.ok(bodyElement); assert.strictEqual('Test Body', bodyElement.textContent); }); }); Running the Tests To run our tests all you need to do is type npm test on your terminal. You'll see something like this: Test Environment This test file we wrote uses Mocha and {sp}Chai for describing tests, and {sp}Karma as the test runner. That's the default setup used by gulp-metal. It's important to note that you don't have to use gulp-metal for you tests though. It's just an easy way that's already provided for you, but you can certainly setup your own environment if you wish. Next steps You should now have a good knowledge of Metal.js basics. If you want to dive into more details and advanced topics, go ahead and check some of our guides. ","srcFilePath":"src/pages/docs/getting-started/modal_testing.md","id":"modal_testing","url":"/docs/getting-started/modal_testing.html"},"modal_updates":{"title":"Tutorial: Modal - Updates","description":"","layout":"guide","weight":300,"content":" In the previous section we learned how to add inline listeners, by making the Modal's close button work. We first implemented this feature by disposing of the entire Modal{sp} instance when it was closed. It'd be best to have the modal just hide itself so it could be shown again afterwards though. State We've seen that it's possible to pass data to components via the constructor. By default this kind of data is read-only for the component though, that is, it can be received from the outside but not changed from the inside. When you need to be able to change a component's data, as well as have that change cause its HTML contents to update, you should indicate that it'll be part of the component's state. This can be done by using your component's STATE static variable, where you an also configure state properties, specifying initial values and validators for example. So let's add a shown property to our Modal state, in src/Modal.js: Modal.STATE = { shown: { // The default value will be: true. value: true } }; For more details about configuring state, check out {sp}this guide. Updating the Template Now we need to update our template to only show the modal when shown is true. // src/Modal.soy /** State properties are passed to the \"render\" template in the same way as config properties. */ &#123;template .render&#125; {@param shown: bool} ... &#123;/template&#125; // src/Modal.js /** State properties are accessed from this.state. */ render() { var cssClass = 'modal'; if (this.state.shown) { cssClass += 'show'; } return ... ; } Updating the close Function Now we can change our close function to just update the state property. // src/Modal.soy close() { this.shown = false; } // src/Modal.js close() { this.state.shown = false; } State changes are automatically detected by Metal.js, causing the component to be rerendered. Since Metal.js uses {sp}Incremental DOM, rerendering will cause minimal DOM updates. In this case, the shown CSS class will be removed from the modal element. Run the Demo Now compile your code with npm run build and open the demo on a browser. Clicking the *x* button will close the modal as before, but inspecting the DOM you'll notice that it's just hidden, not removed from the DOM. Playing With State Data State data makes it very easy to update a component's contents. If you want to quickly see it working you can make some experiments on your browser's JavaScript console for example. First let's hold the Modal(jsx) instance somewhere so we can access it: window.modal = new metal.Modal({ header: 'My Modal', body: 'Built using Metal.js' }); Now run the demo again, go to the browser's console and type: {sp}modal.shown = false. You'll notice that the modal will be hidden as expected. If you now type modal.shown = true, it will show up again. If you want you can also turn header and body into state properties as well. All you have to do is: Add them to STATE, like this: Modal.STATE = { body: { value: 'Default body' }, header: { value: 'Default header' }, shown: { value: true } }; If you're using JSX templates, change the calls to this.props from this{sp} instead. You will also need to change your config from {sp}Modal.STATE = {lb}...{rb} to Modal.PROPS = {lb}...{rb} like this: render() { var cssClass = 'modal'; if (this.props.shown) { cssClass += 'show'; } return × {this.props.header} {this.props.body} OK ; } Modal.PROPS = { body: { value: 'Default body' }, header: { value: 'Default header' }, shown: { value: true } }; Now if you type something like modal.props.header = 'New Header' on the console, the contents will also be updated automatically. Next Steps Our modal is working as expected now. But what if you want to split it into multiple components? How would we use them together? Check it out in the next section. ↪ Tutorial: Modal - Nested Components ","srcFilePath":"src/pages/docs/getting-started/modal_updates.md","id":"modal_updates","url":"/docs/getting-started/modal_updates.html"}},"childIds":["modal","modal_events","modal_updates","modal_nested","modal_testing"]},"guides":{"children":{"alias":{"title":"Alias","description":"","layout":"guide","weight":100,"content":" Alias A straightforward way to import npm dependencies into your module is to use their relative paths, like we do for any other code. For example: import core from '../node_modules/metal/src/core'; Having to supply the relative path to node_modules is not cool though and, besides that, it may cause problems when a module doing that is imported later as an npm dependency of another project, since the paths will change. Knowing that, Metal.js allows importing npm dependencies like you would from a regular node module, just by referencing their names. Note that this will only work when using Metal.js's build tools or adding a similar logic to your build process yourself (though we provide a {sp}babel preset with this logic that you can use separately too). With aliases, the previous example can be rewritten like this: import core from 'metal'; ","srcFilePath":"src/pages/docs/guides/alias.md","id":"alias","url":"/docs/guides/alias.html"},"building":{"title":"Building","description":"","layout":"guide","weight":220,"content":" As we mentioned before, Metal.js components are written in ES6, which means that we need a transpiling process before using it on a website. This can be done via any tools that you prefer, like {sp}webpack or browserify, but we've also published a few tools of our own, which focuses on Metal.js{sp} projects, which we'll talk about here. gulp-metal What this package offers is a a bunch of gulp tasks. There are tasks that can handle not only building JavaScript, as well as Soy compilation, testing, linting and many other things. The tutorials we've provided are all using it, though indirectly, through some npm scripts. To learn how to use gulp-metal{sp} directly take a look at its npm page. metal-cli If you're not a fan of gulp you can still use {sp}metal-cli, which offers almost the same tools, but through the command line. Examples Using Other Tools As was mentioned before, using gulp-metal or metal-cli is not required. You can use your favorite build tool with Metal.js as well. We've created a Github repository full of different examples on how to work with Metal.js, and among other things it has a bunch of examples showing how to use different build tools. {sp}Check it out, and feel free to create an issue or send a pull request for other tools that it may be missing. ","srcFilePath":"src/pages/docs/guides/building.md","id":"building","url":"/docs/guides/building.html"},"component-lifecycle":{"title":"Component Lifecycle","description":"","layout":"guide","weight":130,"content":" Component Lifecycle Components built with Metal.js provide lifecycle methods that can be called when needed. The following example lists all available lifecycle methods, in the order in which they're called class MyComponent extends Component { /** Called when the component is first created, but before it's first rendered. */ created() { } /** Called whenever the component is rendered. */ rendered() { } /** Called when the component is attached to the DOM. The component will automatically be attached when first rendered, but can also be attached (without rerendering the component) by calling the attach method directly. This is a good place to attach event listeners, since the component is available in the page. */ attached() { } /** Called when the component is detached from the DOM. The component will automatically be detached when disposed, but can also be detached (without disposing the component) by calling the detach method directly. This is a good place to detach event listeners, since the component is not available in the page anymore. */ detached() { } /** Called when the component is disposed. This should contain any necessary cleanup, like detaching any remaining events and disposing of sub components and local variables. */ disposed() { } /** Called when the component is about to render. It takes the component state as an argument and you can massage the data before it is passed down to the template. This is only available for Soy Components. */ prepareStateForRender(states) { return Object.assign({}, states); } } ","srcFilePath":"src/pages/docs/guides/component-lifecycle.md","id":"component-lifecycle","url":"/docs/guides/component-lifecycle.html"},"importing":{"title":"Importing a Third Party Component","description":"","layout":"guide","weight":170,"content":" There are now more libraries and frameworks available for front-end development than ever before. It's not uncommon to have five or more of these libraries involved in a single project. But keeping track of all these libraries and making sure they're up-to-date can be tricky. To solve this we can use npm, a package manager that makes it easy to manage all your application's dependencies. In this guide you are going to learn how to get up and running with npm. You'll start by installing the npm command-line utility and then go on to learn about the various commands that are available for managing Metal.js components. Lets get started! Installing Node.js/NPM If you don't already have Node.js or npm installed, head over to the {sp}Node.js website and download the relevant copy of Node.js for your system. The npm program is included with the install of Node.js. Now that you have npm installed, we can start looking at the commands that are used to manage packages. Finding components There are two different ways that you can find npm packages. Either using the online component directory, or using the command line utility. To search for packages on the command line you use the search command. This should be followed by your search query. npm search For example to search for packages that contain the word ‘metal’ you could do the following: npm search metal This command would return a whole bunch of results, with information about each matched module so you can pick the one you wish. Installing Components To add a new npm package to your project you use the install command. This should be passed the name of the package you wish to install. npm install In this example, we're going to install the metal-position component. npm install metal-position Installed packages will be placed in a node_modules directory. This is created in the folder which the bower program was executed. └── node_modules ├── metal ├── metal-position Importing a Component With the code already available, let's create a main.js file that will import the metal-position module. Note that we're using an {sp}alias to easily import npm files. import position from 'metal-position'; This means that you can now call any function from that module, in this example we'll get the viewport height. var viewportHeight = position.getClientHeight(window); console.log(viewportHeight); Metal.js components are written in ES6 (a.k.a ECMAScript 2015), so you can also use ES6 on your code like we did on the example. Since ES6 isn't fully implemented on browsers yet though, either a polyfill or a build process is necessary before using Metal on a website. ","srcFilePath":"src/pages/docs/guides/importing.md","id":"importing","url":"/docs/guides/importing.html"},"inline-events":{"title":"Inline Events","description":"","layout":"guide","weight":150,"content":" Another feature Metal.js has that can be very useful is the ability to declare events inside templates, directly on the desired element. Besides being simple and intuitive, this feature allows Metal.js to handle attaching events itself, and so this can be done in the best way possible, with {sp}delegates for example, without the user having worry about that at all. These events are also automatically detached when the component is disposed. Inline Listeners - via Function Name You can add DOM event listeners easily through your templates, like this: The above code declares that whenever the *x* button is clicked, the {sp}close function from the component should be called. Inline Listeners - via Function Reference If you prefer though, you can also pass the actual function reference (instead of just its name) as an inline listener. // src/Modal.soy /** In the \"render\" template, soy params that match a component's function name will be that function (automatically bound to the component instance). */ &#123;template .render&#125; {@param close: any} // ... // ... &#123;/template} // src/Modal.js That will work exactly the same way as the previous example. Inline Listeners - Nested Components When using nested components it's also possible to inline events by using the events property: // src/Modal.soy {call Button.render} {param events: ['click': ['selector': 'button', 'fn': 'close']] /} {param label: 'Ok' /} {/call} // src/Modal.js var events = {click: { selector: 'button', fn: 'close' }}; This will cause the close function from the sub component to be called whenever a click event triggers for the elements that match the given selector. In case you want to listen to the event with a function from the parent component, just pass the function reference instead of a string, like this: // src/Modal.soy {call Button.render} {param events: ['click': ['selector': 'button', 'fn': $close]] /} {param label: 'Ok' /} {/call} // src/Modal.js var events = {click: { selector: 'button', fn: this.close.bind(this) }}; Besides DOM events, you can also listen to custom events from the sub component in this same way: // src/Modal.soy {call Button.render} {param events: ['labelChanged': $handleLabelChanged] /} {param label: 'Ok' /} {/call} // src/Modal.js var events = {labelChanged: this.handleLabelChanged.bind(this)}; Inline Listeners - Alternative Usage Besides the on[EventName] format you can also use data-on[eventname] for adding inline listeners. For example: Note that this format is supported mainly to enable doing {sp}progressive enhancement, when running Soy templates via Java for example. When templates using the {sp}on[EventName] format run in Java they will output elements with these as actual attributes, which can cause errors in the browser. In JavaScript these are used as element properties instead, so this problem doesn't occur. So feel free to use the format you like best, or that better fits your needs. ","srcFilePath":"src/pages/docs/guides/inline-events.md","id":"inline-events","url":"/docs/guides/inline-events.html"},"jsx-components":{"title":"JSX Components","description":"","layout":"guide","weight":190,"content":" For a practical tutorial on how to build components using JSX templates, make sure to follow the Modal tutorial section. This guide will explain some details about the integration between {sp}Metal.js components and JSX templates. Note that Metal.js is template agnostic, so it's not necessary to use JSX at all. That said, we already provide a very good integration between metal components and JSX, so if you like using it you should give it a try. JSXComponent The only thing you need to do to use JSX in your Metal.js component is to extend from JSXComponent, like this: import JSXComponent from 'metal-jsx'; class MyComponent extends JSXComponent { } export default MyComponent; render Function Now that we've extended from JSXComponent we can use jsx in the render{sp} method to specify what our component should render. import JSXComponent from 'metal-jsx'; class MyComponent extends JSXComponent { render() { return ( Hello {this.state.name} Hello {this.props.location} ; ); } } MyComponent.PROPS = { location: { validator: core.isString, value: 'Mars' } }; MyComponent.STATE = { name: { validator: core.isString, value: 'World' } }; export default MyComponent; Note that your component can have two different types of data: {sp}state and props. The main difference is that props is accessed via this.props and will be the original data received from parent components or the constructor. State is accessed from this.state though, like this.state.name in the previous example, and can be configured to use validators, setters, initial values and other features. Check out the guide about state to learn more about this. Children Props Whenever content is passed inside a component's jsx tag, it will be received through the children props property. That way the component can decide if this content will be rendered at all, and where exactly it should go. For example, imagine a simple list component that receives its items as its content, like this: Item 1 Item 2 Item 3 This could be implemented by using the children props: class List extends JSXComponent { render() { return {this.props.children} } } If you inspect this.props.children you'll notice that it's an array of objects. That gives you a lot of power when handling your component's contents. For example, you can choose to render only part of your children, like this: // Renders only the second item. return {this.props.children[1]} Or even change the data that they should receive before being rendered: // Forces all items to use the 'my-list-item-class' CSS class. this.props.children.forEach(child = { child.class = 'my-list-item-class'; }; return {this.props.children} Functional Components Sometimes you'll create very simple components, that have no other behavior besides rendering their own contents. In this case you can drop using classes, and instead create simple functions that just render the contents instead. For example, let's create a simple Button component as a function: /** Functional components receive the configuration object as the first param. */ var Button = ({ cssClass, label }) = { return {label}; }; You can then use it from parent components in the same way that you'd use a component class, for example: Rendering JSX Components JSX components can either be rendered in the {sp}usual way, or via the JSXComponent.render{sp} function, like this: class Button extends JSXComponent { render() { // Your render logic } } JSXComponent.render(Button, {label: 'OK'}, parent); You can also pass a functional component to it: var Button = props = { // Your render logic }; JSXComponent.render(Button, {label: 'OK'}, parent); Or even render directly via JSX: JSXComponent.render(, parent); JSX Compilation For the integration between Metal.js and JSX to work, the JSX code needs to be compiled via a babel plugin called {sp}babel-plugin-incremental-dom. Using it directly means you'd need to configure it manually though, so we also provide a babel preset that you can use instead. ","srcFilePath":"src/pages/docs/guides/jsx-components.md","id":"jsx-components","url":"/docs/guides/jsx-components.html"},"nested-components":{"title":"Nested Components","description":"","layout":"guide","weight":160,"content":" The ability to reference components inside templates can be very useful. It enables the developer to correctly place the child component at the right position inside the parent in an intuitive way. This can certainly be done with Metal.js components. For example, let's say we've already built a simple component called Button. Now we're building a Modal component, and we want it to render some buttons inside the footer. In Modal's template file we could do the following: // src/Modal.soy {foreach $button in $buttons} {call Button.render} {param label: $button /} {/call} {/foreach} // src/Modal.js var buttons = this.props.buttons.map(button = { return ; }); return {buttons}; When Modal is rendered, the buttons also will be, at the specified position. Besides this, Button components will be automatically instantiated for these elements. Accessing Sub Component Instances But what if we need to access the created instances? That's possible by using {sp}ref. Let's add one to the previous example and see what happens: // src/Modal.soy {foreach $button as $buttons} {call Button.render} {param label: $button /} {param ref: 'button' + index($button) /} {/call} {/foreach} // src/Modal.js var buttons = this.props.buttons.map((button, index) = { return ; }); Now you'll be able to access your sub components through your instance's refs property, like this: modal.refs.button0 // The instance for first button modal.refs.button1 // The instance for second button ","srcFilePath":"src/pages/docs/guides/nested-components.md","id":"nested-components","url":"/docs/guides/nested-components.html"},"performance":{"title":"Performance","description":"","layout":"guide","weight":230,"content":" Performance Metal.js was built from the first with performance in mind. We've run performance tests to compare it with other libraries and got really good results that show the benefits of using it. In one of the tests we made, we built a simple list widget on three different libraries: Metal.js, YUI and React. We then measured the time it took to render those widgets with 1000 items each on three different situations: First Render - Creating and rendering the list for the first time, on a blank element. Decorate - Creating and decorating a list that was previously rendered on the DOM. Update - Changing the contents of the first item of the list, causing a rerender. The chart below shows the results we obtained on Chrome (the higher the bar, the faster it runs): ","srcFilePath":"src/pages/docs/guides/performance.md","id":"performance","url":"/docs/guides/performance.html"},"progressive-enhancement":{"title":"Progressive Enhancement","description":"","layout":"guide","weight":200,"content":" Progressive Enhancement Progressive enhancement{sp} is a feature that is very important for a lot of people. Knowing about this, {sp}Metal.js is prepared to deal with content that already comes rendered from the server. Since Metal.js components use {sp}Incremental DOM by default, rendering on an element with existing content will reuse it instead of repainting everything. It's important to note that building components with Soy also helps with progressive enhancement in another way: by providing a faithful template that can be run by the server without having to duplicate the rendering code or run JavaScript at all. ","srcFilePath":"src/pages/docs/guides/progressive-enhancement.md","id":"progressive-enhancement","url":"/docs/guides/progressive-enhancement.html"},"rendering-components":{"title":"Rendering Components","description":"","layout":"guide","weight":140,"content":" The quick start tutorial explains how to create and render a new component. In its examples components are always being appended directly to the document's body though, but what's usually necessary is to render in a specific position. Replacing an Existing Element If you wish your component to replace an existing element on the DOM, you just need to pass it (or a selector for it) as the element property of the constructor configuration, like this: // Passsing the element itself new Modal({element: elementToReplace}); // Passing a selector to the element new Modal({element: 'elementToReplace'}); Specifying the Parent You can also specify the parent element that should receive the component's contents via the second constructor param, like this: // Passing the element itself new Modal(data, parentElement); // Passing a selector to the element new Modal(data, 'parentElement'); ","srcFilePath":"src/pages/docs/guides/rendering-components.md","id":"rendering-components","url":"/docs/guides/rendering-components.html"},"soy-components":{"title":"Soy Components","description":"","layout":"guide","weight":180,"content":" For a full tutorial on how to build components using Soy templates, make sure to follow the Modal tutorial section. This guide will explain some details about the integration between Metal.js{sp} components and Soy templates. Note that Metal.js is template agnostic, so it's not necessary to use Soy at all. That said, we already provide a very good integration between Metal.js components and Soy, so if you like this template language you should give it a try. Soy.register The only thing you need to do to use Soy templates in your Metal.js{sp} component is to call Soy.register, passing it your component class and the Soy templates you're going to use, like this: import templates from './MyComponent.soy'; import Component from 'metal-component'; import Soy from 'metal-soy'; class MyComponent extends Component { } Soy.register(MyComponent, templates); export default MyComponent; By default, Metal.js will use the Soy template called render as the entry point for rendering. But you can tell us to use a different one if you prefer by passing the name as the last param to the Soy.register call, like this: Soy.register(MyComponent, templates, 'templateName'); Template File Make sure that your Soy file has the entry point template (render by default), otherwise nothing will be rendered. This main template will receive as data a combination of: State data Configuration data (accessed through this.config) Component functions Note that by default all params declared on the component's main Soy template are automatically configured as state properties as well, but without any special configurations (like initial value or validators). If they're {sp}manually defined through the STATE property they will retain the setup specified there though. Any params passed to the component but not directly declared on its main Soy template will be treated as basic configuration data, meaning that changes to them will not automatically rerender the component. They can still be passed down to other templates using data=\"all\", as well be accessed via the config property in the JavaScript file. // Contains all the data received by the component. this.config Soy Compilation For the integration between Metal.js and soy to work, the Soy files need to be compiled via one of our available build tools. That's because they don't just compile the code, but also add some information that help with the integration (like export declarations). The available build tools that correctly compile Soy for Metal.js are: gulp-metal (already included when creating project via generator-metal). metal-cli metal-tools-soy ","srcFilePath":"src/pages/docs/guides/soy-components.md","id":"soy-components","url":"/docs/guides/soy-components.html"},"state":{"title":"State","description":"","layout":"guide","weight":110,"content":" The State class provides a way of defining state properties for the classes that extend it, as well as watching these properties for value changes. The Component class already extends from State by default, besides automatically rerendering when there is a change. If your class doesn't need to render anything it's best to extend from {sp}State directly though. That way you'll have access to its features without also inheriting logic you won't need. Configuring State The following example is a class that extends directly from State and defines a state property named number on itself: import core from 'metal'; import State from 'metal-state'; class Calculator extends State { /** Coverts string numbers to the number type. */ setNumber(val) { if (core.isString(val)) { val = parseInt(val, 10); } return val; } } Calculator.STATE = { number: { // Called whenever a new value is set. Useful when normalizing your // state data. setter: 'setNumber', // Accepts either number or string types. If the validator check fails, // the new value is discarded, and the current value kept. validator: val = core.isNumber(val) || core.isString(val), // Initial value value: 0, // You can, instead of the value option above, use a function to // return the initial value for the state. valueFn: val = 0, // It's also possible to define that a property can only receive a // value once, and later behave as read-only. writeOnce: false } } If you're familiar with YUI, you may recognize this feature and notice that it's very similar to how attributes are defined there. You basically just need to list all attributes you'll be using on the {sp}STATE static variable (on YUI it would be on ATTRS), and provide their configuration options, like initial value and validator. For a list of all valid options, take a look at State's {sp}docs. Internal States You can define a state as internal, for use in your component only. Just add the attribute internal to the configuration object. By doing this, the state will behave exactly as expected, including re-rendering the component. The only difference being, internal states can not be accessed by parent components. This is not necessary for JSX components, since Metal.js JSX components have their own State Manager implementation. For that reason, two static properties are used, STATE and PROPS, that behave much closer to React's {sp}state and props. To see exactly how it works read JSX components section. Calculator.STATE = { number: { ... internal: true } } Accessing and Updating State The constructor can receive a configuration object with initial values to use for its state properties. You can access or change an object's state in the same way you'd access or change any object property. Or you can also call the {sp}setState function, which updates the properties specified by the given object. var obj = new Calculator(); console.log(obj.number); // Prints 0 obj.number = '1'; console.log(obj.number); // Prints 1 obj.setState({number: 2}); console.log(obj.number); // Prints 2 You can also track state value changes by listening to the appropriate event. obj.on('numberChanged', function(event) { // event.prevVal has the previous value. // event.newVal has the new value. }); To see all features of the State class take a look at its {sp}unit tests. Configuration Data Any data passed to the constructor that has not been configured as a state property can still be accessed via config. Changes to these properties won't be tracked, so it's usually intended for your component's options, which are only set from the outside. var obj = new Calculator({ number: 10, foo: 'foo' }); console.log(obj.number); // Prints 2 console.log(obj.foo); // Prints undefined console.log(obj.config.foo); // Prints 'foo' ","srcFilePath":"src/pages/docs/guides/state.md","id":"state","url":"/docs/guides/state.html"},"yeoman-generator":{"title":"Yeoman Generator","description":"","layout":"guide","weight":210,"content":" Yeoman Generator You can organize your Metal.js project in any way you want, but to start out we recommend using the {sp}Yeoman generator we've created, which prepares both the project structure as well as a basic development workflow for you. To use it: Install npm v3.0.0 or newer (if you don't have it yet) Install Yeoman and generator-metal: [sudo] npm i -g yo generator-metal Open the folder that you want to use on your terminal and type: yo metal Answer the generator prompts: Wait for the generator to finish fetching dependencies After those steps you'll get a directory tree similar to this: └── metal-modal ├── demos │ └── index.html ├── node_modules ├── package.json ├── src │ ├── Modal.js │ ├── Modal.soy // Only if Soy was chosen │ └── modal.scss └── test └── Modal.js generator-metal will already include some npm scripts to help you build and test your code, as well as many gulp tasks via {sp}gulp-metal. By the way, the boilerplate zip provided by the {sp}getting started guide was created using {sp}generator-metal. ","srcFilePath":"src/pages/docs/guides/yeoman-generator.md","id":"yeoman-generator","url":"/docs/guides/yeoman-generator.html"}},"title":"Guides","url":"/docs/guides/alias.html","icon":"streams","weight":2,"content":" ","srcFilePath":"src/pages/docs/guides/index.soy","id":"guides","location":"/docs/guides/","childIds":["alias","state","component-lifecycle","rendering-components","inline-events","nested-components","importing","soy-components","jsx-components","progressive-enhancement","yeoman-generator","building","performance"]}},"childIds":["getting-started","guides","search"]}},"childIds":["docs"]}}